% HW2C.m | Mike Brice

% Matrix a
a = [12 2 5; 8 3 7; 4 4 -9];

% Returns the eigenvalues of the matrix a
ee = eig(a);

% Sets the variable tf to logical 0 or False
tf = logical(0);

% Initialize the counter i
i = 0;

% loop while the matrix a is not upper triangular
% The last matrix in the sequence is upper triangular
% tf is a logical value of either 0 or 1. When tf is 1 then the loop with
% terminate because matrix a will be upper triangular
while tf ~= logical(1)
    
    % Calls the QRfactor function and returns the q and R matrices
    [q R] = QRfactor(a);
    
    % Estimates a using A = QR
    a = R*q;
    
    % Update the counter
    i = i + 1;
    
    % Sets the tolerance to 0.0001
    % The tolerance is used for converting 0.0000 and -0.0000 into 0 so the
    % MATLAB function istriu() can work.
    % The number of iterations is dependent on the size of the tolerance.
    % For example if the tolerance is 0.01 it runs for 18 iterations and
    % gets close to the correct values where as a tolerance of 0.0001 runs
    % for 34 iterations and gets the exact same values as the MATLAB
    % function eig() but not in the same order.
    tol = 0.0001; 
    
    % Converts 0.0000 and -0.0000 to 0
    a(a<tol & a>-tol) = 0;
    
    fprintf('The iteration is %d\n', i)
    disp(a)
    
    % Tests if the matrix a is upper triangular. If the matrix is not upper
    % triangular the result is logical(0) or False and if the matrix is
    % upper triangular the result is logical(1) or True
    tf = istriu(a);
end

% Displays the number of iterations
fprintf('The number of iterations was: %d\n', i);

% Displays the diagonal of matrix a. These are the eigenvalues of a
e = diag(a);
disp('The Eigenvalues from QR Factorization')
disp(e)

% Display the eigenvalues of a generated by the MATLAB function eig()
disp('The Eigenvalues from MATLAB function eig()')
disp(ee)

%{
The results from the QR Factorization are the same numbers as the MATLAB
eig() function, but the eig() function displays them in a different order.
 
The number of iterations required to run the code is dependent on when the
matrix a is upper triangular. So instead of a for loop being used, a while
loop was used and the while loop terminates when the matrix a is a upper
triangular matrix. Since the matrix a has numbers such as -0.0000 and
0.0000 which indicate that the values in those positions are so small they
are displayed as 0. Which it can be safe to say they can be rounded to 0 
since the results are displayed to an accuracy of 4 digits, so 0.0000 and
-0.0000 can be rounded to 0. This was needed to be done because the MATLAB
function istriu() needed 0's to determine if the matrix is upper
triangular.
%}